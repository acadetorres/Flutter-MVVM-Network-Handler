import 'dart:developer';
import 'dart:typed_data';

import 'package:flutter/cupertino.dart';
import 'package:logger/logger.dart';
import 'api_response.dart';
import 'api_service.dart';

class NetworkStreamHandler {

  NetworkStreamHandler(this._apiService);

  final ApiService _apiService;

  final logger = Logger(
      filter: null,
      output: null,
      printer : PrettyPrinter());


  T printFirst<T>(List<T> lst) {  //List of generic type taken as function argument
    T first = lst[0]; //Generic type as local variable
    print(first);
    return first; //Generic type as return value
  }


  /// The emitted values are the ones with "yield" keyword. For now, customise ApiService on the class itself
  /// for headers but will try to add later the function so that on initialize of ApiService, headers are
  /// dynamically added
  /// The function fromJson is a function that turns the json response to Dart class, see LoginResponse.fromJson and
  /// MetaResponse.fromJson. LoginResponse and MetaResponse Classes are both generated by a plugin called JSON to DART.
  Stream<ApiResponse<T>> handleNetworkGet<T>(String path, [dynamic Function(dynamic)? fromJson]) async*{
    try {
      yield ApiResponse.loading(true);
      final response = await _apiService.get(path);
      /// OPTIONAL fromJson parameter, if a fromJson function is not given, json can be access with
      /// the _internallinkedhashmap way:
      /// response.values.elementAt(n)[index]["JSON_KEY"] where response is the yielded response from this
      /// function and n is the index(NOT KEY) of the json if more than 1 json object is in the json response
      /// e.g. {data : [], meta : {} } to access data n have to be 0,
      /// response.values.elementAt(0)[index]["JSON_KEY"]

      /// This is too complicated but might come in handy if JSON to DART generators fail
      /// EXAMPLE at dash_board_screen_dynamic_type.dart
      ///
      if (fromJson == null) {
        yield ApiResponse.completed(response);}
      else {
        yield ApiResponse.completed(fromJson(response));
      }
      yield(ApiResponse.loading(false));
    } catch (e) {
      logger.e(e.toString());
      yield(ApiResponse.loading(false));
      yield(ApiResponse.error(e.toString()));
    }
  }



  ///The fields parameter is the POST fields see repository.loginUser on how to make the fields
  Stream<ApiResponse<dynamic>> handleNetworkPost(String path, Map<String, String> fields,  dynamic Function(dynamic) fromJson) async*{
    try {
      yield ApiResponse.loading(true);
      final response = await _apiService.post(path, fields);
      yield ApiResponse.completed(fromJson(response));
      yield ApiResponse.loading(false);
    } catch (e) {
      logger.v(e.toString());
      yield ApiResponse.loading(false);
      yield ApiResponse.error(e.toString());
    }
  }


  ///The fields parameter is the POST fields see repository.loginUser on how to make the fields
  Stream<ApiResponse<dynamic>> handleNetworkPostMultipart(String path, Map<String, String> fields,  dynamic Function(dynamic) fromJson, String filePath, String fileField, [Uint8List? file, String? fileName]) async*{
    try {
      yield ApiResponse.loading(true);
      final response = await _apiService.multiPartPost(path, fields, filePath, fileField, file, fileName);
      yield ApiResponse.completed(fromJson(response));
      yield ApiResponse.loading(false);
    } catch (e) {
      debugPrint(e.toString());
      log(e.toString());
      logger.v(e.toString());
      yield ApiResponse.loading(false);
      yield ApiResponse.error(e.toString());
    }
  }

}